
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Bomberman Funcional</title>
<style>
body { margin:0; background:#222; display:flex; justify-content:center; align-items:center; height:100vh; }
canvas { background:#000; }
#info { position:absolute; top:10px; color:white; font-family:Arial; }
</style>
</head>
<body>
<div id="info">Setas = mover | Espaço = bomba</div>
<canvas id="game" width="480" height="480"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const tileSize = 40;
const rows = 12;
const cols = 12;

let map = [];
for(let y=0;y<rows;y++){
  map[y] = [];
  for(let x=0;x<cols;x++){
    if(y===0||x===0||y===rows-1||x===cols-1|| (y%2===0 && x%2===0)){
      map[y][x] = 1; // parede fixa
    } else if(Math.random() < 0.3 && !(x<3 && y<3)){
      map[y][x] = 2; // bloco destrutível
    } else {
      map[y][x] = 0;
    }
  }
}

let player = {x:1,y:1,alive:true};
let bombs = [];
let explosions = [];
let enemies = [{x:10,y:10,alive:true}];

document.addEventListener("keydown", e=>{
  if(!player.alive) return;
  if(e.key==="ArrowUp") move(0,-1);
  if(e.key==="ArrowDown") move(0,1);
  if(e.key==="ArrowLeft") move(-1,0);
  if(e.key==="ArrowRight") move(1,0);
  if(e.key===" ") placeBomb();
});

function move(dx,dy){
  let nx = player.x+dx;
  let ny = player.y+dy;
  if(map[ny][nx]===0){
    player.x=nx;
    player.y=ny;
  }
}

function placeBomb(){
  if(!bombs.some(b=>b.x===player.x && b.y===player.y)){
    bombs.push({x:player.x,y:player.y,timer:60});
  }
}

function update(){
  bombs.forEach(b=>b.timer--);
  bombs.filter(b=>b.timer<=0).forEach(explode);
  bombs = bombs.filter(b=>b.timer>0);

  explosions.forEach(e=>e.timer--);
  explosions = explosions.filter(e=>e.timer>0);

  enemies.forEach(en=>{
    if(!en.alive) return;
    if(Math.random()<0.02){
      let dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      let d = dirs[Math.floor(Math.random()*4)];
      let nx=en.x+d[0], ny=en.y+d[1];
      if(map[ny][nx]===0){
        en.x=nx; en.y=ny;
      }
    }
  });

  explosions.forEach(e=>{
    if(player.x===e.x && player.y===e.y){
      player.alive=false;
    }
    enemies.forEach(en=>{
      if(en.x===e.x && en.y===e.y){
        en.alive=false;
      }
    });
  });
}

function explode(bomb){
  let dirs=[[0,0],[1,0],[-1,0],[0,1],[0,-1]];
  dirs.forEach(d=>{
    let nx=bomb.x+d[0];
    let ny=bomb.y+d[1];
    if(map[ny][nx]!==1){
      explosions.push({x:nx,y:ny,timer:20});
      if(map[ny][nx]===2){
        map[ny][nx]=0;
      }
    }
  });
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      if(map[y][x]===1){
        ctx.fillStyle="#555";
        ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);
      }
      if(map[y][x]===2){
        ctx.fillStyle="#964B00";
        ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);
      }
    }
  }

  bombs.forEach(b=>{
    ctx.fillStyle="black";
    ctx.beginPath();
    ctx.arc(b.x*tileSize+20,b.y*tileSize+20,10,0,Math.PI*2);
    ctx.fill();
  });

  explosions.forEach(e=>{
    ctx.fillStyle="orange";
    ctx.fillRect(e.x*tileSize,e.y*tileSize,tileSize,tileSize);
  });

  if(player.alive){
    ctx.fillStyle="cyan";
    ctx.fillRect(player.x*tileSize,player.y*tileSize,tileSize,tileSize);
  }

  enemies.forEach(en=>{
    if(en.alive){
      ctx.fillStyle="red";
      ctx.fillRect(en.x*tileSize,en.y*tileSize,tileSize,tileSize);
    }
  });

  if(!player.alive){
    ctx.fillStyle="white";
    ctx.font="40px Arial";
    ctx.fillText("GAME OVER",120,240);
  }
}

function gameLoop(){
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
