<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bomber Zueira Arena - Profissional</title>

<style>
body{
    margin:0;
    background:#0f0f0f;
    overflow:hidden;
    font-family:Arial,Helvetica,sans-serif;
    text-align:center;
    color:white;
}
canvas{
    background:#1a1a1a;
    display:block;
    margin:0 auto;
    border:4px solid #00ffcc;
}
#ui{
    position:absolute;
    top:10px;
    width:100%;
    font-size:18px;
}
#restartBtn{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    padding:10px 20px;
    font-size:18px;
    background:#00ffcc;
    border:none;
    cursor:pointer;
    display:none;
}
</style>
</head>
<body>

<div id="ui">
Player 1 (WASD + F) ðŸ”µ | Player 2 (Setas + Enter) ðŸ”´
</div>

<button id="restartBtn" onclick="restartGame()">Reiniciar</button>

<canvas id="game" width="640" height="640"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const restartBtn = document.getElementById("restartBtn");

const tile = 40;
const rows = 16;
const cols = 16;

let keys = {};
document.addEventListener("keydown",e=>keys[e.key]=true);
document.addEventListener("keyup",e=>keys[e.key]=false);

class Player{
    constructor(x,y,color,controls){
        this.startX=x;
        this.startY=y;
        this.reset();
        this.color=color;
        this.controls=controls;
    }
    reset(){
        this.x=this.startX;
        this.y=this.startY;
        this.alive=true;
        this.activeBomb=null;
    }
    move(){
        if(!this.alive)return;

        let nx=this.x;
        let ny=this.y;

        if(keys[this.controls.up])ny-=3;
        if(keys[this.controls.down])ny+=3;
        if(keys[this.controls.left])nx-=3;
        if(keys[this.controls.right])nx+=3;

        if(!collide(nx,this.y))this.x=nx;
        if(!collide(this.x,ny))this.y=ny;

        if(keys[this.controls.bomb] && !this.activeBomb){
            placeBomb(this);
            keys[this.controls.bomb]=false;
        }
    }
    draw(){
        if(!this.alive)return;
        ctx.fillStyle=this.color;
        ctx.beginPath();
        ctx.arc(this.x+15,this.y+15,15,0,Math.PI*2);
        ctx.fill();
    }
}

class Bomb{
    constructor(x,y,owner){
        this.x=x;
        this.y=y;
        this.timer=90;
        this.owner=owner;
    }
    update(){
        this.timer--;
        if(this.timer<=0)explode(this);
    }
    draw(){
        ctx.fillStyle="black";
        ctx.beginPath();
        ctx.arc(this.x+20,this.y+20,15,0,Math.PI*2);
        ctx.fill();
    }
}

class Explosion{
    constructor(x,y){
        this.x=x;
        this.y=y;
        this.timer=25;
    }
    update(){this.timer--;}
    draw(){
        ctx.fillStyle="orange";
        ctx.fillRect(this.x,this.y,tile,tile);
    }
}

let map=[], bombs=[], explosions=[], gameOver=false;

function generateMap(){
    for(let r=0;r<rows;r++){
        map[r]=[];
        for(let c=0;c<cols;c++){
            if(r%2===1 && c%2===1){
                map[r][c]=1;
            }else if(Math.random()<0.3){
                map[r][c]=2;
            }else{
                map[r][c]=0;
            }
        }
    }
    map[0][0]=map[0][1]=map[1][0]=0;
    map[15][15]=map[14][15]=map[15][14]=0;
}

function drawMap(){
    for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
            if(map[r][c]===1){
                ctx.fillStyle="#555";
                ctx.fillRect(c*tile,r*tile,tile,tile);
            }
            if(map[r][c]===2){
                ctx.fillStyle="#964B00";
                ctx.fillRect(c*tile,r*tile,tile,tile);
            }
        }
    }
}

function collide(x,y){
    let left=Math.floor(x/tile);
    let right=Math.floor((x+30)/tile);
    let top=Math.floor(y/tile);
    let bottom=Math.floor((y+30)/tile);

    return (map[top]?.[left]>0 ||
            map[top]?.[right]>0 ||
            map[bottom]?.[left]>0 ||
            map[bottom]?.[right]>0);
}

function placeBomb(player){
    let gx=Math.floor(player.x/tile)*tile;
    let gy=Math.floor(player.y/tile)*tile;
    let bomb=new Bomb(gx,gy,player);
    bombs.push(bomb);
    player.activeBomb=bomb;
}

function explode(bomb){
    bombs=bombs.filter(b=>b!==bomb);
    bomb.owner.activeBomb=null;

    const dirs=[[0,0],[1,0],[-1,0],[0,1],[0,-1]];

    dirs.forEach(d=>{
        for(let i=0;i<2;i++){
            let x=bomb.x+d[0]*tile*i;
            let y=bomb.y+d[1]*tile*i;
            let r=y/tile, c=x/tile;

            if(map[r] && map[r][c]===1)break;

            explosions.push(new Explosion(x,y));

            if(map[r] && map[r][c]===2){
                map[r][c]=0;
                break;
            }

            damage(x,y);
        }
    });
}

function damage(x,y){
    [p1,p2].forEach(p=>{
        if(p.alive &&
           p.x<x+tile &&
           p.x+30>x &&
           p.y<y+tile &&
           p.y+30>y){
            p.alive=false;
            gameOver=true;
            restartBtn.style.display="block";
        }
    });
}

function restartGame(){
    bombs=[];
    explosions=[];
    gameOver=false;
    restartBtn.style.display="none";
    generateMap();
    p1.reset();
    p2.reset();
}

let p1=new Player(0,0,"cyan",
    {up:"w",down:"s",left:"a",right:"d",bomb:"f"}
);
let p2=new Player(600,600,"red",
    {up:"ArrowUp",down:"ArrowDown",
     left:"ArrowLeft",right:"ArrowRight",
     bomb:"Enter"}
);

generateMap();

function loop(){
    ctx.clearRect(0,0,640,640);

    drawMap();

    if(!gameOver){
        p1.move();
        p2.move();
    }

    p1.draw();
    p2.draw();

    bombs.forEach(b=>{b.update();b.draw();});
    explosions.forEach(e=>{e.update();e.draw();});
    explosions=explosions.filter(e=>e.timer>0);

    if(gameOver){
        ctx.fillStyle="white";
        ctx.font="40px Arial";
        ctx.fillText("FIM DE JOGO",170,320);
    }

    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
